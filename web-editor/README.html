<h1 id="dojo-web-editor"><a href="#dojo-web-editor" class="headerlink" title="@dojo/web-editor"></a>@dojo/web-editor</h1><p><a href="https://travis-ci.org/dojo/web-editor"><img src="https://travis-ci.org/dojo/web-editor.svg?branch=master" alt="Build Status"></a><br><a href="http://codecov.io/github/dojo/web-editor?branch=master"><img src="http://codecov.io/github/dojo/web-editor/coverage.svg?branch=master" alt="codecov.io"></a><br><a href="http://badge.fury.io/js/%40dojo%2Fweb-editor"><img src="https://badge.fury.io/js/%40dojo%2Fweb-editor.svg" alt="npm version"></a></p><p>A package that provides editing and running of Dojo 2 projects in browser.</p><p><strong>WARNING</strong> This is <em>alpha</em> software. This is not yet production ready, so you should use at your own risk.</p><h2 id="Functionality"><a href="#Functionality" class="headerlink" title="Functionality"></a>Functionality</h2><p>The <code>web-editor</code> provides three main errors of functionality:</p><ul><li>The ability to load a JSON file exported from a project using the Dojo 2 CLI command<br><a href="https://github.com/dojo/cli-export-project"><code>@dojo/cli-export-project</code></a> and provide the ability to transpile that project<br>in the browser.</li><li>Provide an abstraction API to allow editing of those project files in the <a href="https://github.com/Microsoft/monaco-editor"><code>monaco-editor</code></a><br>in a browser.</li><li>Provide an API to allow the loaded project to be run in an <code>iframe</code>.</li></ul><p>This package is inteded to be integrated into a website which would provide a more rich user interface to allow editing and running<br>the project in a browser. There is a minimal API implemented in <code>examples/index.html</code> which allows the loading of example projects<br>that are included in this package in <code>projects</code>. This example is available at<br><a href="https://dojo.github.io/web-editor/">dojo.github.io/web-editor/</a></p><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>This is a singleton instance of a class which provides an API to load and manage a project. A project file is a JSON file that<br>conforms to the interface described in<br><a href="https://github.com/dojo/cli-export-project/blob/master/src/interfaces/project.json.d.ts#L6-L64"><code>ProjectJson</code></a> which is part of<br>the <code>@dojo/cli-export-project</code> package.</p><p>Because of the way the <code>monaco-editor</code> works, you can only have one <em>environment</em> per page, and <code>project</code> needs to interface with<br>this environment to instruct the TypeScript services what is available so the editors and the emit for the project work correctly.</p><p>There are several key methods of <code>project</code>:</p><ul><li><code>.load(filename: string): Promise&lt;void&gt;</code> - An async function which will retrieve the specified project bundle and populate the<br>environment with the information from the project. It will resolve when the loading is complete.</li><li><code>.isLoaded(): boolean</code> - Returns <code>true</code> if the project is loaded, otherwise <code>false</code>.</li><li><code>.getFiles(...types: ProjectFileType[]): ProjectFile[]</code> - Returns object representations of the files that can be edited in the<br>project. By default, it will include all the files in the project, but you can specify as many different file types as arguments<br>and only those types of files will be returned.</li><li><code>.getFileNames(...types: ProjectFileType[]): string[]</code> - Returns an array of strings that represent the files that can be edited<br>in the project. This is useful for populating a user interface element of files. By default, it will include all the files<br>in the project, but you can specify as many different file types as arguments and only those types of files will be returned.</li><li><code>.get(): ProjectJson | undefined</code> - Returns the object representation of the project JSON, including any changes that have been made<br>while the project has been loaded.</li></ul><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>Typical usage would be something like this:</p><pre><code class="typescript"><span class="keyword">import</span> project <span class="keyword">from</span> <span class="string">'@dojo/web-editor/project'</span>;

<span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params"></span>) =&gt; {
    <span class="keyword">await</span> project.load(<span class="params">'some.project.json'</span>);
    <span class="built_in">console</span>.log(<span class="params">'Loaded!'</span>);
}</span>)<span class="params">()</span>;</span>
</code></pre><h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p>This is a class which wraps <code>monaco-editor</code>, allowing the editor to seemlessly integrate with the project. It will automatically<br>display files with the appropriate language intellisense as well as the file is edited, changes will automatically be sent to<br>the project to keep it updated.</p><p>The <code>Editor</code> constructor takes two arguments. First, you need to provide a DOM element that will serve as the root for the editor.<br>The second is an optional argument is a pass through of any options as specified in the <code>monaco.editor.IEditorOptions</code> interface.</p><p>The class has only one method:</p><ul><li><code>.display(filename: string): void</code> - Displays the file based on the name supplied. It will throw if the file is not part of the<br>currently loaded project.</li></ul><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><p>Typical usage would be something like this:</p><pre><code class="typescript"><span class="keyword">import</span> project <span class="keyword">from</span> <span class="string">'@dojo/web-editor/project'</span>;
<span class="keyword">import</span> Editor <span class="keyword">from</span> <span class="string">'@dojo/web-editor/Editor'</span>;

<span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params"></span>) =&gt; {
    <span class="keyword">await</span> project.load(<span class="params">'some.project.json'</span>);
    <span class="keyword">const</span> editor = <span class="keyword">new</span> Editor(<span class="params"><span class="built_in">document</span>.getElementById(<span class="params">'editor'</span>)</span>);
    editor.display(<span class="params">'./src/somefile.ts'</span>);
}</span>)<span class="params">()</span>;</span>
</code></pre><h3 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a>Runner</h3><p>This is a class which provides a simple API to run instances of a project within an <code>iframe</code> on a page. It will automatically<br>transpile the project and send the transpiled output to the <code>iframe</code>.</p><p>The <code>Runner</code> constructor takes a single arugment, which is the <code>iframe</code> it should use to run the project in.</p><p>The class has one method of note:</p><ul><li><code>.run(): Promise&lt;void&gt;</code> - an async function which will resolve when the project has been run.</li></ul><h4 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h4><pre><code class="html"><span class="meta">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="name">html</span>&gt;</span>
<span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>
<span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"@dojo/web-worker/support/blank.html"</span> <span class="attr">id</span>=<span class="string">"runner"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span>
<span class="tag">&lt;/<span class="name">html</span>&gt;</span>
</code></pre><pre><code class="typescript"><span class="keyword">import</span> project <span class="keyword">from</span> <span class="string">'@dojo/web-editor/project'</span>;
<span class="keyword">import</span> Runner <span class="keyword">from</span> <span class="string">'@dojo/web-editor/Runner'</span>;

<span class="function">(<span class="params"><span class="keyword">async</span> (<span class="params"></span>) =&gt; {
    <span class="keyword">await</span> project.load(<span class="params">'some.project.json'</span>);
    <span class="keyword">const</span> runner = <span class="keyword">new</span> Runner(<span class="params"><span class="built_in">document</span>.getElementById(<span class="params">'runner'</span>)</span>);
    <span class="keyword">await</span> runner.run(<span class="params"></span>);
    <span class="built_in">console</span>.log(<span class="params">'Ran!'</span>);
}</span>)<span class="params">()</span>;</span>
</code></pre><h3 id="worker-proxy"><a href="#worker-proxy" class="headerlink" title="worker-proxy"></a>worker-proxy</h3><p>This is script which will setup the <code>monaco-editor</code> web workers to be able to provide better performance when editing and running<br>projects. This file should be configured up in the <code>monaco-editor</code> environment before attempting to load the rest of <code>monaco-editor</code>.</p><p>For example, you might have something like this in your web-editor page:</p><pre><code class="html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">
    window.MonacoEnvironment = {
        getWorkerUrl: function () {
            return 'node_modules/@dojo/web-editor/worker-proxy.js';
        }
    };
</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
</code></pre><h3 id="external-postcss-bundle"><a href="#external-postcss-bundle" class="headerlink" title="external/postcss-bundle"></a>external/postcss-bundle</h3><p>In order to properly transpile CSS that is part of a project, the web-editor needs to utilise postcss with additional plugins for this<br>purpose. Because postcss is distributed as a NodeJS package, it is necessary to make this available in the browser with appropriate<br>fills of NodeJS functionality. This is accomplished by creating a WebPack bundle of the modules and exporting the key modules as<br>globals.</p><p>This bundle needs to be loaded prior to loading the AMD loader, otherwise there will be conflicts between the WebPack <code>require()</code> and<br>the AMD <code>require()</code>. It should look something like this:</p><pre><code class="html"><span class="meta">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>
<span class="tag">&lt;<span class="name">body</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@dojo/web-editor/external/postcss-bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"node_modules/@dojo/web-editor/node_modules/monaco-editor/min/vs/loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">
        window.MonacoEnvironment = {
            getWorkerUrl: function () {
                return '../worker-proxy.js';
            }
        };

        require.config({
            paths: {
                'vs': 'node_modules/@dojo/web-editor/node_modules/monaco-editor/min/vs',
                '@dojo': 'node_modules/@dojo'
            }
        });

        require([ './example' ], function () {});
    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>
<span class="tag">&lt;/<span class="name">body</span>&gt;</span>
</code></pre><h3 id="Supporting-Modules"><a href="#Supporting-Modules" class="headerlink" title="Supporting Modules"></a>Supporting Modules</h3><p>There are several modules which are used to support the functionality of the web editor.</p><h3 id="support-providers-amdRequire"><a href="#support-providers-amdRequire" class="headerlink" title="support/providers/amdRequire"></a>support/providers/amdRequire</h3><p>This module is used with <code>@dojo/core/require</code> to make it possible to retrieve inlined resources, like JSON, from a runner application. This<br>will be injected, like the other transpiled modules, which resolve local resources via AMD and pass remote requests to<br><code>@dojo/core/require/providers/xhr</code>.</p><h3 id="support-css"><a href="#support-css" class="headerlink" title="support/css"></a>support/css</h3><p>This module provides the transpilation of CSS for a runner application. It provides the ability to run the CSS through CSSNext and also<br>provides the necessary information to allow CSS Modules to work in Dojo 2 applications.</p><h3 id="support-json"><a href="#support-json" class="headerlink" title="support/json"></a>support/json</h3><p>This module provides the ability to <em>inline</em> JSON to the AMD loader so that local project resources are available to the runner application.</p><h3 id="support-postcss-support-postcssCssnext-support-postcssModules"><a href="#support-postcss-support-postcssCssnext-support-postcssModules" class="headerlink" title="support/postcss, support/postcssCssnext, support/postcssModules"></a>support/postcss, support/postcssCssnext, support/postcssModules</h3><p>These are modules which export the exposed globals from the <code>postcss-bundle</code>.</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>The package is typically instlaled using <code>npm</code>. The distrubition though comes with a version of <code>monaco-editor</code> that uses the current<br>version of TypeScript. Therefore it is often better to use that included version than the version that is currently available, as it<br>appears the general avaialable version lags behind in updating.</p><h2 id="Licensing-Information"><a href="#Licensing-Information" class="headerlink" title="Licensing Information"></a>Licensing Information</h2><p>This package also includes the following libraries and their dependencies:</p><ul><li><a href="https://github.com/Microsoft/monaco-editor"><code>monaco-editor</code></a> - © 2016 Microsoft Corporation. <a href="http://opensource.org/licenses/MIT">MIT</a> license.</li><li><a href="https://github.com/postcss/postcss"><code>postcss</code></a> - © 2013 Andrey Sitnik. <a href="http://opensource.org/licenses/MIT">MIT</a> license.</li><li><a href="https://github.com/MoOx/postcss-cssnext"><code>postcss-cssnext</code></a> - © 2014 Maxime Thirouin. <a href="http://opensource.org/licenses/MIT">MIT</a> license.</li><li><a href="https://github.com/css-modules/postcss-modules"><code>postcss-modules</code></a> - © 2015 - 2016 Alexander Madyankin. <a href="http://opensource.org/licenses/MIT">MIT</a> license.</li></ul><p>© 2017 <a href="https://js.foundation/">JS Foundation</a>. <a href="http://opensource.org/licenses/BSD-3-Clause">New BSD</a> license.</p>